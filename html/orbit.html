
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>orbit</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-03-20"><meta name="DC.source" content="orbit.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">ORBIT Plot orbit trajectory</a></li><li><a href="#2">Set up paths and SPICE kernel files</a></li><li><a href="#3">Load SPICE kernel files</a></li><li><a href="#4">Read input</a></li><li><a href="#8">Get SPICE orbit data</a></li><li><a href="#12">Get SPICE S/C orientation</a></li><li><a href="#21">Find RPC-LAP illumination conditions</a></li><li><a href="#37">Plotting</a></li><li><a href="#49">Output</a></li><li><a href="#51">Unload SPICE kernels</a></li></ul></div><h2>ORBIT Plot orbit trajectory<a name="1"></a></h2><p>orbit(object, time, origin, frame) plots the trajectory of <i>object</i> (string) during the time interval specified by <i>time</i> (1x2 cell array of strings or 2x1 array of double precision values) w.r.t. <i>origin</i> (string) in the reference frame specified by <i>frame</i> (string). The plot is in 3D.</p><p>If time contains more than two epochs, these are used as sample times rather than start/stop times.</p><p>If an output argument is supplied, a 6xN matrix is given containing the six position and velocity components in spherical coordinates for each of the N sample times between the start and stop time specified in the time input argument.</p><p>If two output arguments are supplied, a 3x3xN set of rotation matrices that transforms the components of a vector expressed in the frame specified by 'frame' to components expressed in the frame tied to the object is given as the second output. This represents the orientation/ attitude of the object.</p><p>If three output arguments are supplied, the third is the 1xN row vector of solar aspect angles (w.r.t the object z-axis).</p><p>Available frames are any frames natively recognized by SPICE. Or 'IAU', specifying the body-fixed (rotating) frame cenetered on origin. Or 'Terminal', specifying a frame centered on origin with the x-axis pointing towards the Sun (the z-axis is the orthogonal projection of the IAU z-axis w.r.t the x-axis).</p><p>If time contains more than one epoch, a 2D plot of object's altitude and latitude is produced, in addition to the 3D trajectory plot. (OBS! The latitude values depend on the frame of reference chosen!)</p><p>If time consists of floating point number(s), these are interpreted as representing the number of TDB seconds past the J2000 epoch, i.e. Ephemeris Time (ET). Alternatively, epochs may be supplied in the form of a cell array containing string(s) in any format recognized by SPICE as epochs. (E.g. the ISOC calendar format: YYYY-MM-DDThh:mm:ss.sss)</p><pre class="codeinput"><span class="keyword">function</span> [varargout] = orbit(object, time, origin, frame)
</pre><h2>Set up paths and SPICE kernel files<a name="2"></a></h2><p>PATHS() gives paths to SPICE kernels directory and sets up MICE paths.</p><pre class="codeinput">paths();
</pre><pre class="codeoutput">Warning: Name is nonexistent or not a directory:
/Users/eliasodelstad/Documents/Rosetta/SPICE/mice/src/mice 
Warning: Name is nonexistent or not a directory:
/Users/eliasodelstad/Documents/Rosetta/SPICE/mice/lib 
Warning: Name is nonexistent or not a directory:
/Users/eliasodelstad/Documents/Rosetta/MATLAB/irfu-matlab 
</pre><h2>Load SPICE kernel files<a name="3"></a></h2><p>The SPICE kernel files ahve to be loaded in order to be accessible from MICE, this is done by the the function CSPICE_FURNSH. For convenience, the full list of kernels to load is stored in an external .txt file so that calling CSPICE_FURNSH for this file loads all the kernels at once. OBS! This metakernel textfile contains the absolute search paths to the SPICE kernels and must therefore be configured specifically for the local machine!</p><pre class="codeinput">kernelFile = <span class="string">'metakernel_rosetta.txt'</span>;
cspice_furnsh(kernelFile);
</pre><pre class="codeoutput">Error using mice
SPICE(NOSUCHFILE): [furnsh_c-&gt;FURNSH-&gt;ZZLDKER] The attempt to load "metakernel_rosetta.txt" by the routine FURNSH failed. It could not be located.

Error in cspice_furnsh (line 127)
      mice('furnsh_c',file);

Error in orbit (line 57)
cspice_furnsh(kernelFile);
</pre><h2>Read input<a name="4"></a></h2><p>If time is NOT floating point number(s), convert from string representation of epoch(s) to Ephemeris Time (ET):</p><pre class="codeinput"><span class="keyword">if</span> (isfloat(time))
    t = time;
<span class="keyword">else</span>
    t = cspice_str2et(time);
<span class="keyword">end</span>
</pre><p>If precisely two input epochs are supplied, create equidistant sample times in between. Otherwise, use given epochs as sample times:</p><pre class="codeinput"><span class="keyword">if</span> (length(t) == 2)
    dt = (t(2)-t(1))/10000;
    et = t(1):dt:t(2);
<span class="keyword">else</span>
    et = t;
<span class="keyword">end</span>
</pre><p>Get name of reference frame:</p><pre class="codeinput"><span class="keyword">if</span> (strcmpi(frame, <span class="string">'IAU'</span>) || strcmpi(frame, <span class="string">'Terminal'</span>))
    ref = [frame <span class="string">'_'</span> origin];
<span class="keyword">else</span>
    ref = frame;
<span class="keyword">end</span>
</pre><p>Get reference body radius for normalization purposes:</p><pre class="codeinput">radii = cspice_bodvrd(origin, <span class="string">'RADII'</span>, 3);
R_0 = radii(1);
</pre><h2>Get SPICE orbit data<a name="8"></a></h2><p>Compute orbit states:</p><pre class="codeinput">state = cspice_spkezr(object, et, ref, <span class="string">'LT+S'</span>, origin);
</pre><p>Convert to spherical coordinates:</p><pre class="codeinput">r = @(x) sqrt(sum(x.^2,1));
theta = @(x) acos(x(3,:)./r(x));
phi = @(x) atan(x(2,:)./x(1,:));
S = @(x) [r(x); theta(x); phi(x)];
state_s = [S(state(1:3,:)); S(state(4:6,:))];
</pre><p>Compute altitude and latitude:</p><pre class="codeinput">altitude = state_s(1,:)'-R_0;
latitude = 90-180/pi*state_s(2,:)';
</pre><p>Find direction of the sun:</p><pre class="codeinput">sun = cspice_spkpos(<span class="string">'Sun'</span>, et, ref, <span class="string">'LT+S'</span>, origin);
sun_s = S(sun);
sun_n = sun/sun_s(1)*R_0; <span class="comment">% normalization</span>
</pre><h2>Get SPICE S/C orientation<a name="12"></a></h2><p>Get object NAIF ID code:</p><pre class="codeinput">id = cspice_bodn2c(object);
</pre><p>Convert to corresponding structure id:</p><pre class="codeinput">id_str = id*1000;
</pre><p>Convert epochs to (continuous) spacecraft clock counts:</p><pre class="codeinput">et_s = cspice_sce2c(id, et);
</pre><p>Get change of basis transformation matrix:</p><pre class="codeinput">[cmat, clkout, found] = cspice_ckgp(id_str, et_s, 0, ref);
</pre><p>Compute the inverse of the change of basis transformatation matrix (the COLUMNS of which are the the basis vectors of the S/C frame expressed in the given 'base frame'):</p><pre class="codeinput">[~, ~, num] = size(cmat);
basis = zeros(size(cmat));
<span class="keyword">for</span> i = 1:num
</pre><p>The transformation matrix between two ortho-normal bases on the same vector space is orthogonal, hence cmat^-1 = cmat^T, which is faster:</p><pre class="codeinput">    basis(:,:,i) = cmat(:,:,i)';
<span class="keyword">end</span>
</pre><p>Normalization:</p><pre class="codeinput">basis_n = basis*R_0;
</pre><p>Find direction of the sun in S/C frame:</p><pre class="codeinput">sun_sc = cspice_spkpos(<span class="string">'Sun'</span>, et, <span class="string">'ROS_SPACECRAFT'</span>, <span class="string">'LT+S'</span>, object);
sun_sc_s = S(sun_sc);
<span class="comment">% sun_sc_n = sun_sc/sun_sc_s(1)*R_0; % normalization</span>
</pre><p>Solar aspect angle (w.r.t z-axis in S/C frame, '+' above y-z plane, '-' below)</p><pre class="codeinput">Phi = sun_sc_s(2,:)*180/pi.*sign(pi-sun_sc_s(3,:));
</pre><h2>Find RPC-LAP illumination conditions<a name="21"></a></h2><p>This is only done when <i>object</i> is Rosetta:</p><pre class="codeinput"><span class="keyword">if</span> (id == -226 || id == -226000)
</pre><p><b>Currently unused code for finding illumination boundary angles for arbitrary solar array orientation (though still assumed perpendicular to the Sun):</b></p><p>Get solar array NAIF codes:</p><pre class="language-matlab">id_SA1 = id_str - 15;   <span class="comment">% +Ysc array</span>
id_SA2 = id_str - 25;   <span class="comment">% -Ysc array</span>
</pre><p>Get change of basis transformation matrices:</p><pre class="language-matlab">[cmat_SA1, clkout_SA1, found_SA1] = cspice_ckgp(id_SA1, et_s, 0, <span class="string">'ROS_SPACECRAFT'</span>);
[cmat_SA2, clkout_SA2, found_SA2] = cspice_ckgp(id_SA2, et_s, 0, <span class="string">'ROS_SPACECRAFT'</span>);
</pre><p>Alternative obtainment of the transformation matrices:</p><pre class="language-matlab">rot_SA1 = cspice_pxform(<span class="string">'ROS_SPACECRAFT'</span>, <span class="string">'ROS_SA+Y'</span>, et);
rot_SA2 = cspice_pxform(<span class="string">'ROS_SPACECRAFT'</span>, <span class="string">'ROS_SA-Y'</span>, et);
</pre><p>Compute the inverse of the change of basis transformatation matrix (the COLUMNS of which are the the basis vectors of the instrument frame expressed in the S/C frame):</p><pre class="language-matlab">[~, ~, num] = size(cmat);
basis_SA1 = zeros(size(cmat_SA1));
basis_SA2 = zeros(size(cmat_SA2));
</pre><p>The transformation matrix between two ortho-normal bases on the same vector space is orthogonal, hence cmat^-1 = cmat^T, which is faster.</p><pre class="language-matlab"><span class="keyword">for</span> i = 1:num
    basis_SA1(:,:,i) = cmat_SA1(:,:,i)';
    basis_SA2(:,:,i) = cmat_SA2(:,:,i)';
<span class="keyword">end</span>
</pre><p>Solar array gimbal positions [m] (from RO-DSS-IF-1201 Issue 3):</p><pre class="language-matlab">pos_SA1 = [0, 1.0645, 1.32113]';
pos_SA2 = [0, -1.0645, 1.32113]';
</pre><p>Solar array half-width [m] (from RO-DSS-IF-1201 Issue 3)</p><pre class="language-matlab">SA_HW = 1.125;
</pre><p>RPC-LAP positions [m] (from EAICD-1_8) In S/C frame:</p><pre class="language-matlab">lap1_pos = [-1.19, 2.43, 3.88]';
lap2_pos = [-2.48, 0.78, -0.65]';
</pre><p>In solar array frames:</p><pre class="language-matlab">lap1_pos_SA1 = zeros(3, num);
lap1_pos_SA2 = zeros(3, num);
<span class="keyword">for</span> i = 1:num
    lap1_pos_SA1(:,i) = cmat_SA1(:,:,i)*(lap1_pos - pos_SA1);
    lap1_pos_SA2(:,i) = cmat_SA2(:,:,i)*(lap1_pos - pos_SA2);
<span class="keyword">end</span>
</pre><p>Check illumination: Probe 1 (c.f. lap1geo.pdf):</p><pre class="language-matlab">Phi11 = 131.6;
Phi12 = 178.6;
</pre><p><b>Anders values</b> (converted to the present solar aspect angle definition by ADDING 90 degrees):</p><pre class="codeinput">    Phi11 = 131;
    Phi12 = 181;
    lap1_ill = ((Phi &lt; Phi11) | (Phi &gt; Phi12));
</pre><p>Alternative obtainment of illumination logical (for arbitrary SA orientation, though still perpendicular to the Sun):</p><pre class="language-matlab">lap1_ill = (abs(lap1_pos_SA1(1,:)) &gt; SA_HW);
</pre><p>Probe 2 (c.f. lap2geo.pdf):</p><pre class="language-matlab">Phi21 = 23.5;
Phi22 = 79.6;
Phi23 = 109.3;
</pre><p><b>Anders values</b> (+90 degrees)</p><pre class="codeinput">    Phi21 = 18;
    Phi22 = 82;
    Phi23 = 107;
    lap2_ill = ((Phi &lt; Phi21) | (Phi &gt; Phi22)) - 0.6*((Phi &gt; Phi22) &amp; (Phi &lt; Phi23));

<span class="keyword">end</span>
</pre><h2>Plotting<a name="37"></a></h2><p>If no output argument is provided, give results in the form of plots.</p><pre class="codeinput"><span class="keyword">if</span> (nargout == 0)
</pre><div><ul><li><b>Plot 3D</b></li></ul></div><pre class="codeinput">    figure(<span class="string">'Position'</span>, [0 930 640 480])
</pre><p>Draw sphere: (redundant)</p><pre class="language-matlab">[X, Y, Z] = sphere(20);
</pre><p>Draw ellipsoid:</p><pre class="codeinput">    [X, Y, Z] = ellipsoid(0, 0, 0, radii(1)/R_0, radii(2)/R_0, radii(3)/R_0, 20);
    colormap <span class="string">gray</span>;
    h = surf(R_0*X,R_0*Y,R_0*Z, <span class="string">'CDataMapping'</span>, <span class="string">'direct'</span>, <span class="string">'FaceColor'</span>, <span class="string">'interp'</span>);
    set(gca, <span class="string">'FontSize'</span>, 14);
    hAnnotation = get(h, <span class="string">'Annotation'</span>);
    hLegendEntry = get(hAnnotation, <span class="string">'LegendInformation'</span>);
    set(hLegendEntry, <span class="string">'IconDisplayStyle'</span>, <span class="string">'off'</span>);
    hold;
</pre><p>Plot direction to Sun:</p><pre class="codeinput">    <span class="keyword">if</span> (length(et) == 1 || strcmpi(frame, <span class="string">'terminal'</span>) || strcmpi(frame, <span class="string">'J2000'</span>) <span class="keyword">...</span>
            || strcmpi(frame, <span class="string">'ECLIPJ2000'</span>))
        quiver3(1.1*sun_n(1), 1.1*sun_n(2), 1.1*sun_n(3), sun_n(1), sun_n(2), sun_n(3), <span class="keyword">...</span>
            <span class="string">'r'</span>, <span class="string">'LineWidth'</span>, 2, <span class="string">'DisplayName'</span>, <span class="string">'Sun'</span>);
        C = 24 + 32*ones(size(Z)).*(X*sun_n(1) + Y*sun_n(2) + Z*sun_n(3) &gt; 0);
        set(h, <span class="string">'CData'</span>, C);
    <span class="keyword">end</span>
</pre><p>Plot trajectory and orientation of object:</p><pre class="codeinput">    a = state(1,:);
    b = state(2,:);
    c = state(3,:);
    <span class="keyword">if</span> (length(et) == 1)
</pre><p>Draw position vector:</p><pre class="codeinput">        quiver3(0, 0, 0, a, b, c, 0, <span class="string">'k'</span>, <span class="string">'LineWidth'</span>, 1.2, <span class="string">'DisplayName'</span>, <span class="keyword">...</span>
            [object <span class="string">' position vector'</span>]);
</pre><p>Draw orientation in the form of S/C frame basis vectors</p><pre class="codeinput">        quiver3(a, b, c, basis_n(1,1,1), basis_n(2,1,1), basis_n(3,1,1), <span class="keyword">...</span>
            <span class="string">'g'</span>, <span class="string">'LineWidth'</span>, 1.2, <span class="string">'DisplayName'</span>, [<span class="string">'x '</span> object <span class="string">' S/C frame'</span>]);
        quiver3(a, b, c, basis_n(1,2,1), basis_n(2,2,1), basis_n(3,2,1), <span class="keyword">...</span>
            <span class="string">'m'</span>, <span class="string">'LineWidth'</span>, 1.2, <span class="string">'DisplayName'</span>, [<span class="string">'y '</span> object <span class="string">' S/C frame'</span>]);
        quiver3(a, b, c, basis_n(1,3,1), basis_n(2,3,1), basis_n(3,3,1), <span class="keyword">...</span>
            <span class="string">'b'</span>, <span class="string">'LineWidth'</span>, 1.2, <span class="string">'DisplayName'</span>, [<span class="string">'z '</span> object <span class="string">' S/C frame'</span>]);
        scatter3(a, b, c, <span class="string">'k'</span>, <span class="string">'filled'</span>, <span class="string">'DisplayName'</span>, object);
        axis(min(max(state_s(1,:)), 10*R_0)*[-1 1 -1 1 -1 1])
    <span class="keyword">else</span>
        <span class="keyword">if</span> (strcmpi(frame, <span class="string">'terminal'</span>) == 0 &amp;&amp; strcmpi(frame, <span class="string">'J2000'</span>) == 0 &amp;&amp; <span class="keyword">...</span>
                strcmpi(frame, <span class="string">'ECLIPJ2000'</span>) == 0)
            set(h, <span class="string">'FaceColor'</span>, [0.7 0.7 0.7]);
        <span class="keyword">end</span>
</pre><p>Trajectory:</p><pre class="codeinput">        plot3(a, b, c, <span class="string">'k'</span>, <span class="string">'LineWidth'</span>, 1.2, <span class="string">'DisplayName'</span>, [object <span class="string">' trajectory'</span>]);
</pre><p>Orientation:</p><pre class="codeinput">        Q_scale = 0.05;
        Q_step = 10;
        quiver3(a(1:Q_step:end), b(1:Q_step:end), c(1:Q_step:end), <span class="keyword">...</span>
            squeeze(basis_n(1,1,1:Q_step:end))', squeeze(basis_n(2,1,1:Q_step:end))', <span class="keyword">...</span>
            squeeze(basis_n(3,1,1:Q_step:end))', Q_scale, <span class="string">'g'</span>, <span class="string">'DisplayName'</span>, [<span class="string">'x '</span> object <span class="string">' S/C frame'</span>])
        quiver3(a(1:Q_step:end), b(1:Q_step:end), c(1:Q_step:end), <span class="keyword">...</span>
            squeeze(basis_n(1,2,1:Q_step:end))', squeeze(basis_n(2,2,1:Q_step:end))', <span class="keyword">...</span>
            squeeze(basis_n(3,2,1:Q_step:end))', Q_scale, <span class="string">'m'</span>, <span class="string">'DisplayName'</span>, [<span class="string">'y '</span> object <span class="string">' S/C frame'</span>])
        quiver3(a(1:Q_step:end), b(1:Q_step:end), c(1:Q_step:end), <span class="keyword">...</span>
            squeeze(basis_n(1,3,1:Q_step:end))', squeeze(basis_n(2,3,1:Q_step:end))', <span class="keyword">...</span>
            squeeze(basis_n(3,3,1:Q_step:end))', Q_scale, <span class="string">'b'</span>, <span class="string">'DisplayName'</span>, [<span class="string">'z '</span> object <span class="string">' S/C frame'</span>])
        axis(max(state_s(1,:))*[-1 1 -1 1 -1 1]);
    <span class="keyword">end</span>
    l = legend(<span class="string">'Location'</span>, <span class="string">'NorthEast'</span>);
    set(l, <span class="string">'box'</span>, <span class="string">'off'</span>, <span class="string">'color'</span>, <span class="string">'none'</span>);
    hold <span class="string">off</span>;
</pre><div><ul><li><b>Plot altitude and latitude</b></li></ul></div><pre class="codeinput">    <span class="keyword">if</span>(length(et) &gt; 1)
        figure(<span class="string">'Position'</span>, [640 930 640 480])
        h = irf_plot(1);
        irf_plot(h(1), [irf_time(et,<span class="string">'et2epoch'</span>)'  altitude], <span class="string">'k'</span>, <span class="string">'LineWidth'</span>, 2);
        set(h(1), <span class="string">'FontSize'</span>, 18);
        set(get(gca, <span class="string">'XLabel'</span>), <span class="string">'FontSize'</span>, get(h(1), <span class="string">'FontSize'</span>));
        ylabel(<span class="string">'Altitude (km)'</span>, <span class="string">'FontSize'</span>, get(h(1), <span class="string">'FontSize'</span>));
        limY = ylim;
        axis <span class="string">tight</span>;
        ylim(limY);

        h(2) = axes(<span class="string">'Position'</span>,get(h(1),<span class="string">'Position'</span>));
        irf_plot(h(2), [irf_time(et,<span class="string">'et2epoch'</span>)' latitude], <span class="string">'r'</span>, <span class="string">'LineWidth'</span>, 2);
        set(h(2), <span class="string">'FontSize'</span>, get(h(1), <span class="string">'FontSize'</span>), <span class="string">'YAxisLocation'</span>, <span class="string">'right'</span>, <span class="string">'Color'</span>, <span class="string">'none'</span>, <span class="string">'box'</span>, <span class="keyword">...</span>
            <span class="string">'off'</span>, <span class="string">'YColor'</span>, <span class="string">'r'</span>);
        set(get(gca, <span class="string">'XLabel'</span>), <span class="string">'FontSize'</span>, get(h(2), <span class="string">'FontSize'</span>));
        ylabel(<span class="string">'Latitude (\circ)'</span>, <span class="string">'FontSize'</span>, get(h(2), <span class="string">'FontSize'</span>));
        limY = ylim;
        axis <span class="string">tight</span>;
        ylim(limY);
    <span class="keyword">end</span>
</pre><div><ul><li><b>Plot solar ascpect angle (for Rosetta)</b></li></ul></div><pre class="codeinput">    <span class="keyword">if</span> (id == -226 || id == -226000)
        figure(<span class="string">'Position'</span>, [1280 930 640 480])
        H = irf_plot(1);
        irf_plot(H(1), [irf_time(et,<span class="string">'et2epoch'</span>)'  Phi'], <span class="string">'k'</span>, <span class="string">'LineWidth'</span>, 2);
        set(H(1), <span class="string">'FontSize'</span>, 18);
        set(get(H(1), <span class="string">'XLabel'</span>), <span class="string">'FontSize'</span>, get(H(1), <span class="string">'FontSize'</span>));
        ylabel(<span class="string">'Solar aspect angle (\circ)'</span>, <span class="string">'FontSize'</span>, get(H(1), <span class="string">'FontSize'</span>));
        axis <span class="string">tight</span>;
        xl = xlim;
        ylim([0 180]);
        colour = [0.4 0.4 0.4];
        alpha = 0.5;
        hold;
        patch([xl(1) xl(1) xl(2) xl(2)], [Phi11 Phi12 Phi12 Phi11], colour, <span class="keyword">...</span>
            <span class="string">'FaceAlpha'</span>, alpha, <span class="string">'EdgeColor'</span>, colour, <span class="string">'EdgeAlpha'</span>, alpha)
        patch([xl(1) xl(1) xl(2) xl(2)], [Phi21 Phi22 Phi22 Phi21], colour, <span class="keyword">...</span>
            <span class="string">'FaceAlpha'</span>, alpha, <span class="string">'EdgeColor'</span>, colour, <span class="string">'EdgeAlpha'</span>, alpha)
        patch([xl(1) xl(1) xl(2) xl(2)], [Phi22 Phi23 Phi23 Phi22], 1-colour, <span class="keyword">...</span>
            <span class="string">'FaceAlpha'</span>, alpha, <span class="string">'EdgeColor'</span>, 1-colour, <span class="string">'EdgeAlpha'</span>, alpha)
        text(xl(2), Phi12, <span class="string">'Probe 1 shaded'</span>, <span class="keyword">...</span>
            <span class="string">'FontSize'</span>, get(H(1), <span class="string">'FontSize'</span>), <span class="string">'VerticalAlignment'</span>, <span class="string">'top'</span>, <span class="keyword">...</span>
            <span class="string">'HorizontalAlignment'</span>, <span class="string">'right'</span>);
        text(xl(2), Phi21, <span class="string">'Probe 2 shaded'</span>, <span class="keyword">...</span>
            <span class="string">'FontSize'</span>, get(H(1), <span class="string">'FontSize'</span>), <span class="string">'VerticalAlignment'</span>, <span class="string">'bottom'</span>, <span class="keyword">...</span>
            <span class="string">'HorizontalAlignment'</span>, <span class="string">'right'</span>);
        text(xl(2), Phi23, <span class="string">'Probe 2 HGA shade'</span>, <span class="keyword">...</span>
            <span class="string">'FontSize'</span>, get(H(1), <span class="string">'FontSize'</span>), <span class="string">'VerticalAlignment'</span>, <span class="string">'top'</span>, <span class="keyword">...</span>
            <span class="string">'HorizontalAlignment'</span>, <span class="string">'right'</span>);
    <span class="keyword">end</span>
</pre><h2>Output<a name="49"></a></h2><p>Several output formats are possible depending on the number of output arguments given.</p><pre class="codeinput"><span class="keyword">elseif</span> (nargout == 1)
    varargout = {altitude};
<span class="keyword">elseif</span> (nargout == 2)
    varargout = {altitude, latitude};
<span class="keyword">elseif</span> (nargout == 3)
    varargout = {altitude, latitude, Phi};
<span class="keyword">elseif</span> (nargout == 4)
    varargout = {altitude, latitude, Phi, et};
<span class="keyword">end</span>
</pre><h2>Unload SPICE kernels<a name="51"></a></h2><p>It is important to unload the kernel files at the end of the program so that successive executions won't fill up the kernel pool.</p><pre class="codeinput">cspice_unload(kernelFile);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ORBIT Plot orbit trajectory
% orbit(object, time, origin, frame) plots the trajectory of _object_
% (string) during the time interval specified by _time_ (1x2 cell array of
% strings or 2x1 array of double precision values) w.r.t. _origin_ (string)
% in the reference frame specified by _frame_ (string). The plot is in 3D.
%
% If time contains more than two epochs, these are used as sample times
% rather than start/stop times.
%
% If an output argument is supplied, a 6xN matrix is given containing the
% six position and velocity components in spherical coordinates for each
% of the N sample times between the start and stop time specified in the
% time input argument.
%
% If two output arguments are supplied, a 3x3xN set of rotation matrices 
% that transforms the components of a vector expressed in the frame 
% specified by 'frame' to components expressed in the frame tied to the 
% object is given as the second output. This represents the orientation/
% attitude of the object.
%
% If three output arguments are supplied, the third is the 1xN row vector
% of solar aspect angles (w.r.t the object z-axis).
%   
% Available frames are any frames natively recognized by SPICE. Or 'IAU',
% specifying the body-fixed (rotating) frame cenetered on origin. Or
% 'Terminal', specifying a frame centered on origin with the x-axis
% pointing towards the Sun (the z-axis is the orthogonal projection of
% the IAU z-axis w.r.t the x-axis).
%   
% If time contains more than one epoch, a 2D plot of object's altitude and
% latitude is produced, in addition to the 3D trajectory plot. (OBS! The
% latitude values depend on the frame of reference chosen!)
%
% If time consists of floating point number(s), these are interpreted as 
% representing the number of TDB seconds past the J2000 epoch, i.e.
% Ephemeris Time (ET). Alternatively, epochs may be supplied in the form
% of a cell array containing string(s) in any format recognized by SPICE
% as epochs. (E.g. the ISOC calendar format: YYYY-MM-DDThh:mm:ss.sss)

function [varargout] = orbit(object, time, origin, frame)

%% Set up paths and SPICE kernel files
% PATHS() gives paths to SPICE kernels directory and sets up MICE paths.

paths();

%% Load SPICE kernel files
% The SPICE kernel files ahve to be loaded in order to be accessible from
% MICE, this is done by the the function CSPICE_FURNSH. For convenience,
% the full list of kernels to load is stored in an external .txt file so
% that calling CSPICE_FURNSH for this file loads all the kernels at once.
% OBS! This metakernel textfile contains the absolute search paths to the
% SPICE kernels and must therefore be configured specifically for the local
% machine!

kernelFile = 'metakernel_rosetta.txt';
cspice_furnsh(kernelFile);

%% Read input
% If time is NOT floating point number(s), convert from string
% representation of epoch(s) to Ephemeris Time (ET):
if (isfloat(time))
    t = time;
else
    t = cspice_str2et(time);
end

%%%
% If precisely two input epochs are supplied, create equidistant sample
% times in between. Otherwise, use given epochs as sample times:
if (length(t) == 2)
    dt = (t(2)-t(1))/10000;
    et = t(1):dt:t(2);
else
    et = t;
end

%%%
% Get name of reference frame:
if (strcmpi(frame, 'IAU') || strcmpi(frame, 'Terminal'))
    ref = [frame '_' origin];
else
    ref = frame;
end

%%%
% Get reference body radius for normalization purposes:
radii = cspice_bodvrd(origin, 'RADII', 3);
R_0 = radii(1);

%% Get SPICE orbit data
% Compute orbit states:
state = cspice_spkezr(object, et, ref, 'LT+S', origin);

%%%
% Convert to spherical coordinates:
r = @(x) sqrt(sum(x.^2,1));
theta = @(x) acos(x(3,:)./r(x));
phi = @(x) atan(x(2,:)./x(1,:));
S = @(x) [r(x); theta(x); phi(x)];
state_s = [S(state(1:3,:)); S(state(4:6,:))];

%%%
% Compute altitude and latitude:
altitude = state_s(1,:)'-R_0;
latitude = 90-180/pi*state_s(2,:)';

%%%
% Find direction of the sun:
sun = cspice_spkpos('Sun', et, ref, 'LT+S', origin);
sun_s = S(sun);
sun_n = sun/sun_s(1)*R_0; % normalization

%% Get SPICE S/C orientation
% Get object NAIF ID code:
id = cspice_bodn2c(object);

%%%
% Convert to corresponding structure id:
id_str = id*1000;

%%%
% Convert epochs to (continuous) spacecraft clock counts:
et_s = cspice_sce2c(id, et);

%%%
% Get change of basis transformation matrix:
[cmat, clkout, found] = cspice_ckgp(id_str, et_s, 0, ref);

%%%
% Compute the inverse of the change of basis transformatation matrix (the 
% COLUMNS of which are the the basis vectors of the S/C frame expressed in
% the given 'base frame'):
[~, ~, num] = size(cmat);
basis = zeros(size(cmat));
for i = 1:num
    %%%
    % The transformation matrix between two ortho-normal bases on the same
    % vector space is orthogonal, hence cmat^-1 = cmat^T, which is faster:
    basis(:,:,i) = cmat(:,:,i)';
end

%%%
% Normalization:
basis_n = basis*R_0;

%%%
% Find direction of the sun in S/C frame:
sun_sc = cspice_spkpos('Sun', et, 'ROS_SPACECRAFT', 'LT+S', object);
sun_sc_s = S(sun_sc);
% sun_sc_n = sun_sc/sun_sc_s(1)*R_0; % normalization

%%%
% Solar aspect angle (w.r.t z-axis in S/C frame, '+' above y-z plane, '-' below)
Phi = sun_sc_s(2,:)*180/pi.*sign(pi-sun_sc_s(3,:));

%% Find RPC-LAP illumination conditions
% This is only done when _object_ is Rosetta:
if (id == -226 || id == -226000)
    
    %%% 
    % *Currently unused code for finding illumination boundary angles for
    % arbitrary solar array orientation (though still assumed perpendicular
    % to the Sun):*
    
    %%%
    % Get solar array NAIF codes:
    %
    %   id_SA1 = id_str - 15;   % +Ysc array
    %   id_SA2 = id_str - 25;   % -Ysc array
    
    %%%
    % Get change of basis transformation matrices:
    %
    %   [cmat_SA1, clkout_SA1, found_SA1] = cspice_ckgp(id_SA1, et_s, 0, 'ROS_SPACECRAFT');
    %   [cmat_SA2, clkout_SA2, found_SA2] = cspice_ckgp(id_SA2, et_s, 0, 'ROS_SPACECRAFT');
    
    %%%
    % Alternative obtainment of the transformation matrices:
    %
    %   rot_SA1 = cspice_pxform('ROS_SPACECRAFT', 'ROS_SA+Y', et);
    %   rot_SA2 = cspice_pxform('ROS_SPACECRAFT', 'ROS_SA-Y', et);
    
    %%%
    % Compute the inverse of the change of basis transformatation matrix (the 
    % COLUMNS of which are the the basis vectors of the instrument frame expressed in
    % the S/C frame):
    %
    %   [~, ~, num] = size(cmat);
    %   basis_SA1 = zeros(size(cmat_SA1));
    %   basis_SA2 = zeros(size(cmat_SA2));
        
        %%%
        % The transformation matrix between two ortho-normal bases on the same
        % vector space is orthogonal, hence cmat^-1 = cmat^T, which is faster.
        %
        %   for i = 1:num
        %       basis_SA1(:,:,i) = cmat_SA1(:,:,i)';
        %       basis_SA2(:,:,i) = cmat_SA2(:,:,i)';
        %   end
    
    %%%
    % Solar array gimbal positions [m] (from RO-DSS-IF-1201 Issue 3):
    %
    %   pos_SA1 = [0, 1.0645, 1.32113]';
    %   pos_SA2 = [0, -1.0645, 1.32113]';
    
    %%%
    % Solar array half-width [m] (from RO-DSS-IF-1201 Issue 3)
    % 
    %   SA_HW = 1.125;

    %%%
    % RPC-LAP positions [m] (from EAICD-1_8)
    % In S/C frame:
    %
    %   lap1_pos = [-1.19, 2.43, 3.88]';
    %   lap2_pos = [-2.48, 0.78, -0.65]';

    %%%
    % In solar array frames:
    %
    %   lap1_pos_SA1 = zeros(3, num);
    %   lap1_pos_SA2 = zeros(3, num);
    %   for i = 1:num
    %       lap1_pos_SA1(:,i) = cmat_SA1(:,:,i)*(lap1_pos - pos_SA1);
    %       lap1_pos_SA2(:,i) = cmat_SA2(:,:,i)*(lap1_pos - pos_SA2);
    %   end
    
    %%%
    % Check illumination:
    % Probe 1 (c.f. lap1geo.pdf):
    %
    %   Phi11 = 131.6;
    %   Phi12 = 178.6;

    %%%
    % *Anders values* (converted to the present solar aspect angle definition
    % by ADDING 90 degrees):
    Phi11 = 131;
    Phi12 = 181;
    lap1_ill = ((Phi < Phi11) | (Phi > Phi12));
    
    %%%
    % Alternative obtainment of illumination logical (for arbitrary SA
    % orientation, though still perpendicular to the Sun):
    %
    %   lap1_ill = (abs(lap1_pos_SA1(1,:)) > SA_HW);
    
    %%%
    % Probe 2 (c.f. lap2geo.pdf):
    %
    %   Phi21 = 23.5;
    %   Phi22 = 79.6;
    %   Phi23 = 109.3;

    %%%
    % *Anders values* (+90 degrees)
    Phi21 = 18;
    Phi22 = 82;
    Phi23 = 107;
    lap2_ill = ((Phi < Phi21) | (Phi > Phi22)) - 0.6*((Phi > Phi22) & (Phi < Phi23));

end

%% Plotting
% If no output argument is provided, give results in the form of plots.

if (nargout == 0)
    %%
    % * *Plot 3D*
    figure('Position', [0 930 640 480])
    
    %%%
    % Draw sphere: (redundant)
    %
    %   [X, Y, Z] = sphere(20);
    
    %%%
    % Draw ellipsoid:
    [X, Y, Z] = ellipsoid(0, 0, 0, radii(1)/R_0, radii(2)/R_0, radii(3)/R_0, 20);
    colormap gray;
    h = surf(R_0*X,R_0*Y,R_0*Z, 'CDataMapping', 'direct', 'FaceColor', 'interp');
    set(gca, 'FontSize', 14);
    hAnnotation = get(h, 'Annotation');
    hLegendEntry = get(hAnnotation, 'LegendInformation');
    set(hLegendEntry, 'IconDisplayStyle', 'off');
    hold;
    
    %%%
    % Plot direction to Sun:
    if (length(et) == 1 || strcmpi(frame, 'terminal') || strcmpi(frame, 'J2000') ...
            || strcmpi(frame, 'ECLIPJ2000'))
        quiver3(1.1*sun_n(1), 1.1*sun_n(2), 1.1*sun_n(3), sun_n(1), sun_n(2), sun_n(3), ...
            'r', 'LineWidth', 2, 'DisplayName', 'Sun');
        C = 24 + 32*ones(size(Z)).*(X*sun_n(1) + Y*sun_n(2) + Z*sun_n(3) > 0);
        set(h, 'CData', C);
    end

    %%%
    % Plot trajectory and orientation of object:
    a = state(1,:);
    b = state(2,:);
    c = state(3,:);
    if (length(et) == 1)
        %%%
        % Draw position vector:
        quiver3(0, 0, 0, a, b, c, 0, 'k', 'LineWidth', 1.2, 'DisplayName', ...
            [object ' position vector']);
        %%%
        % Draw orientation in the form of S/C frame basis vectors
        quiver3(a, b, c, basis_n(1,1,1), basis_n(2,1,1), basis_n(3,1,1), ...
            'g', 'LineWidth', 1.2, 'DisplayName', ['x ' object ' S/C frame']);
        quiver3(a, b, c, basis_n(1,2,1), basis_n(2,2,1), basis_n(3,2,1), ...
            'm', 'LineWidth', 1.2, 'DisplayName', ['y ' object ' S/C frame']);
        quiver3(a, b, c, basis_n(1,3,1), basis_n(2,3,1), basis_n(3,3,1), ...
            'b', 'LineWidth', 1.2, 'DisplayName', ['z ' object ' S/C frame']);
        scatter3(a, b, c, 'k', 'filled', 'DisplayName', object);
        axis(min(max(state_s(1,:)), 10*R_0)*[-1 1 -1 1 -1 1])
    else
        if (strcmpi(frame, 'terminal') == 0 && strcmpi(frame, 'J2000') == 0 && ...
                strcmpi(frame, 'ECLIPJ2000') == 0)
            set(h, 'FaceColor', [0.7 0.7 0.7]);
        end
        %%%
        % Trajectory:
        plot3(a, b, c, 'k', 'LineWidth', 1.2, 'DisplayName', [object ' trajectory']);
        %%%
        % Orientation:
        Q_scale = 0.05;
        Q_step = 10;
        quiver3(a(1:Q_step:end), b(1:Q_step:end), c(1:Q_step:end), ...
            squeeze(basis_n(1,1,1:Q_step:end))', squeeze(basis_n(2,1,1:Q_step:end))', ...
            squeeze(basis_n(3,1,1:Q_step:end))', Q_scale, 'g', 'DisplayName', ['x ' object ' S/C frame'])
        quiver3(a(1:Q_step:end), b(1:Q_step:end), c(1:Q_step:end), ...
            squeeze(basis_n(1,2,1:Q_step:end))', squeeze(basis_n(2,2,1:Q_step:end))', ...
            squeeze(basis_n(3,2,1:Q_step:end))', Q_scale, 'm', 'DisplayName', ['y ' object ' S/C frame'])
        quiver3(a(1:Q_step:end), b(1:Q_step:end), c(1:Q_step:end), ...
            squeeze(basis_n(1,3,1:Q_step:end))', squeeze(basis_n(2,3,1:Q_step:end))', ...
            squeeze(basis_n(3,3,1:Q_step:end))', Q_scale, 'b', 'DisplayName', ['z ' object ' S/C frame'])
        axis(max(state_s(1,:))*[-1 1 -1 1 -1 1]);
    end
    l = legend('Location', 'NorthEast');
    set(l, 'box', 'off', 'color', 'none');
    hold off;

    %%
    % * *Plot altitude and latitude*
    if(length(et) > 1)    
        figure('Position', [640 930 640 480])
        h = irf_plot(1);
        irf_plot(h(1), [irf_time(et,'et2epoch')'  altitude], 'k', 'LineWidth', 2);
        set(h(1), 'FontSize', 18);
        set(get(gca, 'XLabel'), 'FontSize', get(h(1), 'FontSize'));
        ylabel('Altitude (km)', 'FontSize', get(h(1), 'FontSize'));
        limY = ylim;
        axis tight;
        ylim(limY);

        h(2) = axes('Position',get(h(1),'Position'));
        irf_plot(h(2), [irf_time(et,'et2epoch')' latitude], 'r', 'LineWidth', 2);
        set(h(2), 'FontSize', get(h(1), 'FontSize'), 'YAxisLocation', 'right', 'Color', 'none', 'box', ...
            'off', 'YColor', 'r');
        set(get(gca, 'XLabel'), 'FontSize', get(h(2), 'FontSize'));
        ylabel('Latitude (\circ)', 'FontSize', get(h(2), 'FontSize'));
        limY = ylim;
        axis tight;
        ylim(limY);
    end

    %%
    % * *Plot solar ascpect angle (for Rosetta)*
    if (id == -226 || id == -226000)
        figure('Position', [1280 930 640 480])
        H = irf_plot(1);
        irf_plot(H(1), [irf_time(et,'et2epoch')'  Phi'], 'k', 'LineWidth', 2);
        set(H(1), 'FontSize', 18);
        set(get(H(1), 'XLabel'), 'FontSize', get(H(1), 'FontSize'));
        ylabel('Solar aspect angle (\circ)', 'FontSize', get(H(1), 'FontSize'));
        axis tight;
        xl = xlim;
        ylim([0 180]);
        colour = [0.4 0.4 0.4];
        alpha = 0.5;
        hold;
        patch([xl(1) xl(1) xl(2) xl(2)], [Phi11 Phi12 Phi12 Phi11], colour, ...
            'FaceAlpha', alpha, 'EdgeColor', colour, 'EdgeAlpha', alpha)
        patch([xl(1) xl(1) xl(2) xl(2)], [Phi21 Phi22 Phi22 Phi21], colour, ...
            'FaceAlpha', alpha, 'EdgeColor', colour, 'EdgeAlpha', alpha)
        patch([xl(1) xl(1) xl(2) xl(2)], [Phi22 Phi23 Phi23 Phi22], 1-colour, ...
            'FaceAlpha', alpha, 'EdgeColor', 1-colour, 'EdgeAlpha', alpha)    
        text(xl(2), Phi12, 'Probe 1 shaded', ...
            'FontSize', get(H(1), 'FontSize'), 'VerticalAlignment', 'top', ...
            'HorizontalAlignment', 'right');
        text(xl(2), Phi21, 'Probe 2 shaded', ...
            'FontSize', get(H(1), 'FontSize'), 'VerticalAlignment', 'bottom', ...
            'HorizontalAlignment', 'right');
        text(xl(2), Phi23, 'Probe 2 HGA shade', ...
            'FontSize', get(H(1), 'FontSize'), 'VerticalAlignment', 'top', ...
            'HorizontalAlignment', 'right');
    end

%% Output
% Several output formats are possible depending on the number of output
% arguments given.
elseif (nargout == 1)
    varargout = {altitude};
elseif (nargout == 2)
    varargout = {altitude, latitude};
elseif (nargout == 3)
    varargout = {altitude, latitude, Phi};
elseif (nargout == 4)
    varargout = {altitude, latitude, Phi, et};
end

%% Unload SPICE kernels
% It is important to unload the kernel files at the end of the program so
% that successive executions won't fill up the kernel pool.
cspice_unload(kernelFile);

end
































##### SOURCE END #####
--></body></html>